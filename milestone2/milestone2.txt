CS162 Milestone 2: Implementation Plan 
	John Meeker
	Ken Hwang

Topic - Worlds

Description:
"This is a recent clever idea about allowing a programmer to explicitly sprout off "alternate worlds" 
where they can perform actions that have no affect on the main world, and optionally then integrate 
those changes back into the main world."


/**************************/
--- Implementation Plan ---
/**************************/
1) What have you learned about the topic you selected?
	The notion of worlds is to make a new language construct that redefines the role of a program state. 
	All computation takes place within a world (changes to global and local variables, arrays, objects, 
	etc.), and the world also keeps track of all these changes. Worlds are first class values that can be
	handled as variables, passed as arguments to a function, and can even be garbage-collected like any
	other object. A new world can be "sprouted" from an existing world at any given time, and the state 
	of a child world is derived from the state of its parent. However, changes and side effects that occur
	inside the child do not affect the parent. At the same time, the side effects captured in the child
	world can be propagated to its parent with a commit operation.
	
2) What safety properties must be satisfied?
	a. Preventing Surprises
		-Changes to variables in the parent world, either explicitly or implicitly, do not spontaneously
		appear in child worlds.
		-If changes are made to variables in the parent world, only propagate them to other sprouted worlds
		that have not yet read or modified that variable.
	
	b. Preserving Consistency
		-A commit from a child world to a parent world is only allowed to happen if, at the time of commit,
		all of the variables read by the child have the same values in the parent as they did when they
		were first read by the child world. (Called a serializability check).
		-If a commit fails a serializability check, then both the child and parent worlds will remain
		unchanged and CommitFailed exception will be thrown.
		
3) What is your vision for the final version of your project, based on what you have learned? You could 
include some made-up programs in that final language as an example of what you intend.
	Our final vision for our project is to incorporate all of the features discussed above, especially
	accounting for the constraints detailed in the safety properties. We want to design a new way for
	developers to write programs by giving them the ability to sprout, commit, compare,	and push updates 
	across several different worlds.
	
	
4) How will you get to that final vision?
	The plan to reach our final vision is to start with the notC language and expanding its functionality
	to include the features of the worlds implementation. 
	Steps:
		1. Add 'world' class to notC as a first class value
		2. Build sprout() and commit() functionality. sprout() will create a copy of the current world, commit() will 
			apply changes in the child world to the parent world. At first, the child changes will be pushed into the 
			parent world unconditionally. 
		3. Build flags on all pushable variables to note if they have been accessed or overwritten; this is to assist with
			pushing changes back to the parent. 
		4. Use flags to determine if commiting is possible, and if propagation down to unchanged children is possible. 
		5. If time permits, children worlds can consume other children worlds, aquiring all the changes of the consumed world. 


/**************************/
--- Collaboration Plan ---
/**************************/
We plan to work on our strategy and approach to the overall project as whole, focusing on the syntatical
and semantic issues. Individually, we are going to divide the functionality implementation steps as evenly
as possible. We want to test our implementation thoroughly, and will do so by having code reviewed and 
tested by the entire group. With this approach, we hope that the end result will be a robust and useful
addition to the notC language.
