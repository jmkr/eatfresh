CS162 Milestone 2: Implementation Plan 
	John Meeker
	Ken Hwang

Topic - Worlds

Description:
"This is a recent clever idea about allowing a programmer to explicitly sprout off "alternate worlds" 
where they can perform actions that have no affect on the main world, and optionally then integrate 
those changes back into the main world."


======================
Implementation Plan
======================
1) What have you learned about the topic you selected?
	The notion of worlds is to make a new language construct that redefines the role of a program state. 
	All computation takes place within a world (changes to global and local variables, arrays, objects, 
	etc.), and the world also keeps track of all these changes. Worlds are first class values that can be
	handled as variables, passed as arguments to a function, and can even be garbage-collected like any
	other object. A new world can be "sprouted" from an existing world at any given time, and the state 
	of a child world is derived from the state of its parent. However, changes and side effects that occur
	inside the child do not affect the parent. At the same time, the side effects captured in the child
	world can be propagated to its parent with a commit operation.
	
2) What safety properties must be satisfied?
	a. Preventing Surprises
		-Changes to variables in the parent world, either explicitly or implicitly, do not spontaneously
		appear in child worlds.
		-If changes are made to variables in the parent world, only propagate them to other sprouted worlds
		that have not yet read or modified that variable.
	
	b. Preserving Consistency
		-A commit from a child world to a parent world is only allowed to happen if, at the time of commit,
		all of the variables read by the child have the same values in the parent as they did when they
		were first read by the child world. (Called a serializability check).
		-If a commit fails a serializability check, then both the child and parent worlds will remain
		unchanged and CommitFailed exception will be thrown.

3) What is your vision for the final version of your project, based on what you have learned?
	


You could include some made-up programs in that final language as an example of what you intend.

How will you get to that final vision?

As I stated above, you should describe an incremental series of milestones so that you're guaranteed 
to always have something to turn in even if your vision turns out to be too ambitious.

====================
Collaboration Plan
====================