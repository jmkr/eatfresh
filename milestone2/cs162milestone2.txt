CS162 Project Milestone 2
Project Implementation Plan

Topic:
Worlds

Description:
"This is a recent clever idea about allowing a programmer to explicitly sprout off "alternate worlds" 
where they can perform actions that have no affect on the main world, and optionally then integrate 
those changes back into the main world."

Group Members:
David Schnurr
James Ebentier
Vincent Alindogan

======================
Implementation Plan
======================

What have you learned about the topic you selected?

    The general idea behind Worlds is to diverge from the usual imperative style programs with
    a global mutable state in favor of a format where the program can fork off into other "worlds"
    to perform experiments and other error-prone tasks. As the paper "Worlds: Controlling the Scope
    of Side Effects" describes it, Worlds are first class values that can be assigned to a variable
    or passed as an argument to a function. The side effects experienced in a child world may be
    committed back into the parent worlds that created it if desired.

    There are also a couple safety properties that must be satisfied:

        "No suprises" says that changes to variables in the parent world should only propograte to
        sprouted worlds that have not read or modified that variable, and thus cannot have been
        affected by it's value.

        "Consistency" says that commits from a child world should never leave the parent in an
        inconsistent state, and that each sprouted world must pass a serializability check when
        committing back to the parent.

What is your vision for the final version of your project, based on what you have learned?
You could include some made-up programs in that final language as an example of what you intend.

    Our vision for the final version of the project is a language that contains all the features
    mentioned above with a few others which we think would be useful. Programmers will be able
    to sprout new worlds, commit sprouted worlds as a whole or select elements, compare two worlds
    using basic comparison operators, pull changes from parent worlds into sprouted worlds, and
    executing code inside of another world. 

    Here is an example of a made-up program might look like after adding worlds to notC:

    var
        a = unit,
        b = unit,
        c = unit,
        d = unit
    in
        a = thisWorld;
        b = a.sprout();

        in b {
            c = thisWorld.sprout();  << thisWorld refers to b here >>
            in c {
                d = 7
            };
            c.commit()
        };

        b.commit();
        output d;   << prints 7 >>

        d = 23;
        b.update();

        in b {
            output d    << prints 23 >>
        }

    Clearly this program does nothing useful, but it's a provides an example of how the
    programmer might interact with worlds.

How will you get to that final vision?

    We plan on starting with notC as our base language, and then taking an incremental approach
    to adding worlds functionality to the language. The order of functionality implementation 
    will be as follows:
        1) Add World class into syntax as first class value
        2) Instantiation using "thisWorld"
        3) Sprouting of new worlds using "Var = World.sprout()"
        4) Changing state of world using "in World { block }"
        5) Commit child world changes to parent world using "World.commit()"
        6) Add comparison operations for Worlds (i.e. ==, != )
        7) Pulling of current state from parent world using "World.update()"

===================
Collaboration Plan
====================

How do you plan to collaborate on the project?

    Intial brainstorming of syntactical and semantics implementation will be done with the entire group.
    Then we will work in groups of one and two splitting up the incremental tasks in an attempt not to
    overload any one group member. Whoever is not currently working on the implementation of a given
    aspect will be working on the creation of test programs to test all cases within the new implementation.

